import { ProductInfo, Cve } from '../models';
import axios from 'axios';
import { CommandOptions } from './ecs-client';
import saveCpesToDb from './helpers/saveCpesToDb';
import saveCvesToDb from './helpers/saveCvesToDb';
import { plainToClass } from 'class-transformer';
import * as c from 'wappalyzer/technologies/c.json';

interface CpeProduct {
  cpe_product_name: string;
  version_number: string;
  vender: string;
}
interface CveEntry {
  cve_uid: string;
  cve_name: string;
  published_date: string;
  last_modified_date: string;
  vuln_status: string;
  description: string;
  cvss_v2_source: string;
  cvss_v2_type: string;
  cvss_v2_version: string;
  cvss_v2_vector_string: string;
  cvss_v2_base_score: number;
  cvss_v2_base_severity: string;
  cvss_v2_exploitability_score: number;
  cvss_v2_impact_score: number;
  cvss_v3_source: string;
  cvss_v3_type: string;
  cvss_v3_version: string;
  cvss_v3_vector_string: string;
  cvss_v3_base_score: number;
  cvss_v3_base_severity: string;
  cvss_v3_exploitability_score: number;
  cvss_v3_impact_score: number;
  cvss_v4_source: string;
  cvss_v4_type: string;
  cvss_v4_version: string;
  cvss_v4_vector_string: string;
  cvss_v4_base_score: number;
  cvss_v4_base_severity: string;
  cvss_v4_exploitability_score: number;
  cvss_v4_impact_score: number;
  weaknesses: string[];
  reference_urls: string[];
  cpe_list: string[];
  vender_product: { [key: string]: CpeProduct[] };
}
interface CvssEndpointResponse {
  task_id: string;
  status: string;
  result?: {
    total_pages: number;
    current_page: number;
    data: CveEntry[];
  };
  error?: string;
}

const fetchCveData = async (page: number) => {
  console.log('Creating task to fetch CVE data');
  try {
    const response = await axios({
      url: 'https://api.staging-cd.crossfeed.cyber.dhs.gov/pe/apiv1/cves_by_modified_date',
      method: 'POST',
      headers: {
        Authorization: String(process.env.CF_API_KEY),
        access_token: String(process.env.PE_API_KEY),
        'Content-Type': '' //this is needed or else it breaks because axios defaults to application/json
      },
      data: {
        page: page,
        per_page: 200
      }
    });
    if (response.status >= 200 && response.status < 300) {
      //console.log('Request was successful');
    } else {
      console.log('Request failed');
    }
    return response.data as CvssEndpointResponse;
  } catch (error) {
    console.log(`Error making POST request: ${error}`);
  }
};
const fetchCveDataTask = async (task_id: string) => {
  console.log('Fetching CVE data');
  try {
    const response = await axios({
      url: `https://api.staging-cd.crossfeed.cyber.dhs.gov/pe/apiv1/cves_by_modified_date/task/${task_id}`,
      headers: {
        Authorization: String(process.env.CF_API_KEY),
        access_token: String(process.env.PE_API_KEY),
        'Content-Type': ''
      }
    });
    if (response.status >= 200 && response.status < 300) {
      //console.log('Request was successful');
    } else {
      console.log('Request failed');
    }
    return response.data as CvssEndpointResponse;
  } catch (error) {
    console.log(`Error making POST request: ${error}`);
  }
};
//notes: add limit to number of times to retry
async function main() {
  let done = false;
  let page = 1;
  let total_pages = 2;

  while (done == false) {
    let taskRequest = await fetchCveData(page);
    console.log(`Fetching page ${page} of page ${total_pages}`);
    await new Promise((r) => setTimeout(r, 1000));
    if (taskRequest?.status == 'Processing') {
      while (taskRequest?.status == 'Processing') {
        //console.log('Waiting for task to complete');
        await new Promise((r) => setTimeout(r, 1000));
        taskRequest = await fetchCveDataTask(taskRequest.task_id);
        //console.log(taskRequest?.status);
      }
      if (taskRequest?.status == 'Completed') {
        console.log(`Task completed successfully for page: ${page}`);

        const cveArray = taskRequest?.result?.data || []; //TODO, change this to CveEntry[]

        for (const cve of cveArray) {
          const cpeArray: ProductInfo[] = [];
          for (const vender in cve.vender_product) {
            for (const product of cve.vender_product[vender]) {
              cpeArray.push(
                plainToClass(ProductInfo, {
                  cpe_product_name: product.cpe_product_name,
                  version_number: product.version_number,
                  vender: product.vender,
                  last_seen: new Date(Date.now())
                })
              );
            }
          }
          const ids: string[] = await saveCpesToDb(cpeArray);
          //SAVE CVE TO DATABASE
          const cvesId: string = await saveCvesToDb(
            plainToClass(Cve, {
              cve_name: cve.cve_name,
              published_date: new Date(cve.published_date),
              last_modified_date: new Date(cve.last_modified_date),
              vuln_status: cve.vuln_status,
              description: cve.description,
              cvss_v2_source: cve.cvss_v2_source,
              cvss_v2_type: cve.cvss_v2_type,
              cvss_v2_version: cve.cvss_v2_version,
              cvss_v2_vector_string: cve.cvss_v2_vector_string,
              cvss_v2_base_score: cve.cvss_v2_base_score,
              cvss_v2_base_severity: cve.cvss_v2_base_severity,
              cvss_v2_exploitability_score: cve.cvss_v2_exploitability_score,
              cvss_v2_impact_score: cve.cvss_v2_impact_score,
              cvss_v3_source: cve.cvss_v3_source,
              cvss_v3_type: cve.cvss_v3_type,
              cvss_v3_version: cve.cvss_v3_version,
              cvss_v3_vector_string: cve.cvss_v3_vector_string,
              cvss_v3_base_score: cve.cvss_v3_base_score,
              cvss_v3_base_severity: cve.cvss_v3_base_severity,
              cvss_v3_exploitability_score: cve.cvss_v3_exploitability_score,
              cvss_v3_impact_score: cve.cvss_v3_impact_score,
              cvss_v4_source: cve.cvss_v4_source,
              cvss_v4_type: cve.cvss_v4_type,
              cvss_v4_version: cve.cvss_v4_version,
              cvss_v4_vector_string: cve.cvss_v4_vector_string,
              cvss_v4_base_score: cve.cvss_v4_base_score,
              cvss_v4_base_severity: cve.cvss_v4_base_severity,
              cvss_v4_exploitability_score: cve.cvss_v4_exploitability_score,
              cvss_v4_impact_score: cve.cvss_v4_impact_score,
              weaknesses: cve.weaknesses,
              reference_urls: cve.reference_urls,
              cpe_list: cve.cpe_list
            }),
            ids
          );
        }
        total_pages = taskRequest?.result?.total_pages || 1;
        const current_page = taskRequest?.result?.current_page || 1;
        if (current_page >= total_pages) {
          done = true;
          console.log(`Finished fetching CVE data`);
        }
        page = page + 1;
      }
    } else {
      done = true;
      console.log(
        `Error fetching CVE data: ${taskRequest?.error} and status: ${taskRequest?.status}`
      );
    }
  }
}
export const handler = async (CommandOptions) => {
  await main();
};
